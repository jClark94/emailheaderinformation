package emailheaderinformation.analysers;

import emailheaderinformation.MainWindow;
import emailheaderinformation.model.VulnerabilityDisclosure;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;

public class VulnerabilityFinderManagerImpl implements VulnerabilityFinderManager {
  private Set<String> mKeywordSet;
  private MainWindow mMainWindow;
  private Map<Date, VulnerabilityDisclosure> disclosureSet;

  public VulnerabilityFinderManagerImpl (MainWindow mainWindow) {
    mKeywordSet = new ConcurrentSkipListSet<>();
    mMainWindow = mainWindow;
    disclosureSet = new ConcurrentHashMap<>();
  }

  @Override public Set<String> getKeywords () {
    return mKeywordSet;
  }

  @Override public Collection<VulnerabilityDisclosure> getVulnerabilities () {
    return disclosureSet.values();
  }

  @Override
  public Map<String, List<VulnerabilityDisclosure>> getMostRelevantVulnerabilities() {
    Map<String, List<VulnerabilityDisclosure>> map = new HashMap<>();
    for (String keyword : mKeywordSet) {
      ArrayList<VulnerabilityDisclosure> vulnerabilityDisclosures = new ArrayList<>();
      disclosureSet.forEach((date, disclosure) -> {
        if (disclosure.getProduct().equals(keyword)) {
          if (vulnerabilityDisclosures.size() < 3) {
            vulnerabilityDisclosures.add(disclosure);
          } else {
            VulnerabilityDisclosure oldest = null;
            for (VulnerabilityDisclosure disclosure1 : vulnerabilityDisclosures) {
              if (oldest == null ||
                  (oldest.getDate().before(disclosure1.getDate()) && disclosure1.getDate().before(
                      disclosure.getDate()))) {
                oldest = disclosure1;
              }
            }
            if (oldest != null) {
              vulnerabilityDisclosures.remove(oldest);
              vulnerabilityDisclosures.add(disclosure);
            }
          }
        }
      });

      map.put(keyword, vulnerabilityDisclosures);
    }
    return map;
  }

  @Override public boolean noVulnerabilitiesFound () {
    return disclosureSet.isEmpty();
  }

  @Override public void lookupVulnerabilityForKeyword (String keyword) {
    StringBuilder sb = new StringBuilder();
    String trimmedKeyword = keyword.trim();
    char[] chars = new char[trimmedKeyword.length()];
    trimmedKeyword.getChars(0, trimmedKeyword.length(), chars, 0);
    for (int i = 0, length = chars.length; i < length; i++) {
      char c = chars[i];
      if (Character.isUpperCase(c)) {
        sb.append(Character.toLowerCase(c));
      } else if (Character.isSpaceChar(c)) {
        sb.append(':');
      } else if (c == '(' || c == '[' || c == '{') {
        if (Character.isSpaceChar(chars[i - 1])) {
          sb.deleteCharAt(sb.length() - 1);
        }
        break;
      } else {
        sb.append(c);
      }
    }
    String normalisedProduct = sb.toString();

    // don't repopulate
    if (!mKeywordSet.contains(normalisedProduct)) {
      // prevent other processes adding the same results
      mKeywordSet.add(normalisedProduct);
      VulnerabilityAnalyser va = new VulnerabilityAnalyser(null,
                                                           mMainWindow,
                                                           normalisedProduct,
                                                           disclosureSet);
      mMainWindow.submitToExecutorService(va);
    }
  }
}
